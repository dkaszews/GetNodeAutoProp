// Provided as part of GetNodeAutoProp under MIT license, (c) 2024 Dominik Kaszewski

using Microsoft.CodeAnalysis;
using System;
using System.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace GetNodeAutoProp
{
    [AttributeUsage(AttributeTargets.Field)]
    public class GetNodeAttribute : Attribute
    {
        public string Path { get; }

        public GetNodeAttribute(string path = "")
            => this.Path = path;
    }

    [Generator]
    public class Generator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var nodes = context.SyntaxProvider.ForAttributeWithMetadataName(
                    "GetNodeAutoProp.GetNodeAttribute",
                    (node, _) => true,
                    (node, _) => node
            ).Collect();

            context.RegisterSourceOutput(nodes, (c, d) => new SourceProvider(c).Process(d));
        }
    }

    public class SourceProvider
    {
        private SourceProductionContext context;

        public SourceProvider(SourceProductionContext context)
            => this.context = context;

        public void Process(IEnumerable<GeneratorAttributeSyntaxContext> data)
        {
            var comparer = SymbolEqualityComparer.Default;
            var groupedByClass = data.GroupBy(x => x.TargetSymbol.ContainingType, comparer);
            foreach (var group in groupedByClass)
            {
                ProcessClass((INamedTypeSymbol)group.Key, group.AsEnumerable());
            }
        }

        private void ProcessClass(INamedTypeSymbol @class, IEnumerable<GeneratorAttributeSyntaxContext> group)
        {
            var source = new StringBuilder();
            var filename = $"{@class.ToDisplayString()}.g.cs";
            source.AppendLine($"// {filename} auto-generated by GetNodeAutoProp");

            if (!@class.ContainingNamespace.IsGlobalNamespace)
            {
                var @namespace = @class.ContainingNamespace.ToDisplayString();
                source.AppendLine($"namespace {@namespace};");
                source.AppendLine();
            }

            source.AppendLine($"partial class {@class.Name}");
            source.AppendLine("{");

            foreach (var attribute in group)
            {
                source.AppendLine(WriteAttribute(attribute));
            }

            source.AppendLine("}");
            source.AppendLine();
            context.AddSource(filename, source.ToString());
        }

        string WriteAttribute(GeneratorAttributeSyntaxContext attribute)
        {
            string Capitalize(string s)
            {
                return char.ToUpperInvariant(s[0]) + s.Substring(1);
            }

            string ResolvePath(ImmutableArray<AttributeData> attributes, string fallback)
            {
                var args = attributes
                    .First(a => a.AttributeClass.Name == "GetNodeAttribute")
                    .ConstructorArguments;
                var value = (string)args[0].Value;
                return !string.IsNullOrEmpty(value) ? value : fallback;
            }

            var field = (IFieldSymbol)attribute.TargetSymbol;
            var type = field.Type.WithNullableAnnotation(NullableAnnotation.None);
            var name = Capitalize(field.Name.Trim('_'));
            var path = ResolvePath(attribute.Attributes, name);

            return $"    private {type} {name} => {field.Name} ??= GetNode<{type}>(\"{path}\");";
        }
    }
}

